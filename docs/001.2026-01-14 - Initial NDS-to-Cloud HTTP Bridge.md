# AetherShell Developer Log 001

## Project Phase: The Initial Bridge (NDS -> Ngrok -> Flask)

**Status:** Success (Bi-directional communication established)

### Networking Context & Constraints

- **Hardware:** Nintendo DS (ARM9)
- **Infrastructure:** ngrok Free Tier (Tunneling) + Local Flask Server (Python 3.10)
- **Network Protocol:** HTTP/1.1 over Plaintext TCP Sockets.
- **Physical Layer (The WiFi Compromise):** - The NDS hardware natively supports only **WEP** or **Open** (unencrypted) networks.
  - Since WEP is deprecated and unavailable on modern routers, an **Open, Hidden SSID** was used as the gateway. This bypasses the DS's lack of WPA2/WPA3 support while maintaining a basic layer of "security through obscurity."

---

### Technical Implementation Details

#### 1. The "Ngrok Interstitial" Bypass

**Problem:** Modern tunneling services like ngrok serve a "Browser Warning" page to prevent phishing. Because the DS uses raw sockets, it cannot execute JavaScript or click "Accept," causing the connection to hang on the HTML response.
**Solution:** Injected a custom HTTP header `ngrok-skip-browser-warning: 1` into the raw request buffer in `main.cpp`.
**Result:** Direct access to the API endpoint without the interstitial interference.

#### 2. The Port Mapping & Scheme Strategy

- **Local Machine:** The Flask API was configured to listen on `port 8080`.
- **Tunneling Command:** `ngrok http 8080 --scheme http`
- **DS Client:** The `SERVER_PORT` macro was set to `80`.

**Logic:** Even though Flask is at 8080, the DS communicates with ngrok's public URL via the standard HTTP Port 80.
**Crucial Note:** We must force `--scheme http`. The NDS hardware lacks the processing power and root certificates required for SSL/TLS (HTTPS) handshakes. Forcing HTTP ensures the packets remain in plaintext, which the ARM9 can parse using standard C string functions.

#### 3. Low-Level Hardware Integration (devkitPro/libnds)

To achieve this bridge, we utilized the following stacks:

- **`libdswifi9.a`:** The core NDS WiFi library. We used `Wifi_InitDefault(true)` to pull connection settings directly from the DS firmware's WFC memory.
- **`dswifi9.h`:** Provided the state machine for `Wifi_AssocStatus()`, allowing the program to wait for a successful handshake with the Access Point.
- **BSD Sockets (`sys/socket.h` & `netdb.h`):** Standard POSIX-style networking. `gethostbyname()` was used to resolve the ngrok hostname to a temporary IP address.

---

### Trial & Error Notes

- **Hardware Limitations:** Attempted various WPA-to-WEP bridges, but ultimately settled on a **Hidden Open SSID** as the only stable method for the 802.11b radio in the DS.
- **DNS Resolution:** Initially, DNS resolution was a failure point. Ensuring `Wifi_InitDefault` was fully associated before calling `gethostbyname` was the fix.
- **Payload Limits:** Discovered that large HTTP responses can overflow the small 1024-byte buffer. Responses must stay lightweight (plaintext is best).
- **CRLF Necessity:** The HTTP protocol requires strict `\r\n` (Carriage Return + Line Feed) endings for headers. Standard `\n` caused 400 Bad Request errors on the Flask side.

---

### Milestones Achieved

- [x] Initialized NDS WiFi Stack.
- [x] Resolved public DNS via NDS.
- [x] Successfully bypassed ngrok security walls via custom headers.
- [x] Forced plaintext HTTP scheme to accommodate DS hardware limitations.
- [x] Established connectivity via Hidden Open Access Point.
- [x] Received plaintext response from Python backend on the NDS console.
