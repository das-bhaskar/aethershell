# AetherShell Developer Log 010

## Project AetherShell: Cloud-to-AR Tunneling & Synchronized Multi-Port Hub

**Version:** 1.6  
**Date:** 2026-01-15  
**Subject:** Implementing Dual-Port Architecture and Secure Public Exposure for iOS AR Integration

---

## 1. Executive Summary

Log 010 documents the expansion of the AetherShell Hub from a local coordinate-receiver to a **Global AR Gateway**. While Log 009 focused on the Vision AI pipeline, this phase addresses the "Last Mile": getting the generated raster assets from a local Java environment onto an iOS device via the public internet. I successfully implemented a **Dual-Connector Architecture** in Spring Boot, allowing simultaneous low-latency ingestion from the NDS (Port 8080) and high-security API delivery for iOS (Port 8443) via a **Cloudflare Quick Tunnel**.

---

## 2. Infrastructure Evolution

### A. The Dual-Port Listener Strategy

To ensure the Nintendo DS's aging WiFi stack remained unaffected by modern web security requirements, I decoupled the communication channels:

1.  **Primary Port (8080):** Dedicated to the NDS. It remains "raw" and open, optimized for the high-frequency POST requests of resistive touch coordinate frames.
2.  **Secondary Port (8443):** Dedicated to the iOS AR client. This port is configured with **Cross-Origin Resource Sharing (CORS)** and serves as the entry point for the Cloudflare Tunnel.

This isolation prevents the heavy SSL/TLS overhead required by Apple's **App Transport Security (ATS)** from choking the limited processing power of the NDS hardware.

### B. Automatic Session Sanitization

A critical requirement for the AR experience is "Asset Freshness." I implemented a **Synchronized Cleanup Logic** within the `/session/new` endpoint. Every time a user initiates a new session (Pressing **Y** on the NDS), the Hub now:

- Resolves the absolute project root path dynamically.
- Purges all `.png` files in the `static/output/` directory.
- Resets the `ConcurrentHashMap` state.

This prevents the iOS client from accidentally polling or rendering "ghost frames" from previous drawing sessions.

---

## 3. Technical Implementation Details

### A. Programmatic Tomcat Customization

Rather than running two separate server instances, I utilized a `WebServerFactoryCustomizer` to inject a second `Connector` into the embedded Tomcat container. This allows the application to listen on multiple ports within a single JVM process.

````java
// Configuration snippet for Port 8443 Injection
Connector additionalConnector = new Connector("org.apache.coyote.http11.Http11NioProtocol");
additionalConnector.setPort(8443);
server.addAdditionalTomcatConnectors(additionalConnector);```

## B. Public Exposure via Cloudflare Tunneling

To bypass NAT restrictions and provide a secure HTTPS endpoint for iOS, I deployed a Cloudflared tunnel. This creates a secure outbound-only bridge to the Cloudflare Edge, providing a stable URL while keeping the local machine's IP hidden.

**Tunnel Configuration:**
- Local Address: http://localhost:8443
- Protocol: QUIC (for optimized mobile performance)
- Encryption: Full SSL/TLS termination at the Edge.

## 4. Technical Performance Table

| Metric            | Technical Implementation                     | Result                                                     |
|------------------|---------------------------------------------|-----------------------------------------------------------|
| Port Density      | Dual Tomcat Connectors (8080/8443)          | Zero interference between DS and iOS                      |
| Asset Latency     | Absolute Path Resource Mapping               | Instant availability of PNGs after Python render          |
| Connectivity      | Cloudflare Quick Tunnel                      | HTTPS-ready public URL without port forwarding            |
| State Integrity   | FileSystemUtils Recursive Purge              | 100% "Fresh Slate" per session start                     |
| Security          | Global CORS Registry (*)                     | Seamless asset fetching for ARKit/RealityKit             |

## 5. The iOS AR Pipeline (Planned Integration)

The assets are now publicly available at `https://[tunnel-id].trycloudflare.com/output/`. The iOS app's workflow is established as:

1. **Polling:** Fetching JSON metadata from the results endpoint.
2. **Chroma Keying:** Using CIFilter (Core Image) to strip white backgrounds from the NDS sketches.
3. **Texture Swapping:** Applying processed frames as a TextureResource loop to an SCNPlane or RealityKit Entity.

## 6. Key Technical Decisions

- **Volatile Session Tracking:** The `currentSessionId` is marked as volatile to ensure that when the NDS starts a session on Port 8080, the iOS polling request on Port 8443 sees the update instantly across different threads.
- **Strict File Filtering:** The cleanup logic ignores non-image files (like `.gitkeep`), ensuring the directory structure remains intact for the Spring ResourceHandler.
- **Absolute Rooting:** By using `System.getProperty("user.dir")`, the Hub remains portable across different dev environments (macOS/Linux) without hardcoding user paths.

## 7. Summary

Log 010 marks the successful "Externalization" of the AetherShell project. We have moved from a closed-loop system (NDS -> Python -> Hub) to a world-ready API. By implementing a dual-port strategy and secure tunneling, the Hub now acts as a professional-grade relay between 2004 gaming hardware and 2026 Augmented Reality. The backend is finalized; the stage is set for the Swift/ARKit frontend.

````
