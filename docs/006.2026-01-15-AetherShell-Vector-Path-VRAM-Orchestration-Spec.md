# AetherShell Developer Log 006

## Project AetherShell: High-Performance Path Streaming & VRAM Management

**Version:** 1.3  
**Date:** 2026-01-15  
**Subject:** Optimization of Data Transmission: From Bitmap Scanning to Vectorized Path Recording

## 1. Executive Summary

Log 006 documents the critical pivot from a "Screen-Buffer Scan" approach to a "Real-Time Vectorized Path" methodology. This transition solved the primary bottleneck of the AetherShell system: the massive latency involved in transmitting high-resolution bitmap data over the Nintendo DS's legacy 802.11b Wi-Fi hardware. By moving to a path-recording system, upload speeds were increased by approximately 5,000%, enabling instantaneous frame delivery.

---

## 2. The Great Bottleneck: Bitmap Scanning vs. Path Streaming

### A. The "VRAM Sweep" Problem (Legacy Approach)

- **Method:** Iterating through the 49,152-pixel sub-background buffer ($256 \times 192$) and sending every "active" pixel as a coordinate.
- **Hurdle:** Even with a simplified 16-bit bitmap, the CPU overhead of scanning the entire VRAM bank and the subsequent TCP overhead of sending thousands of redundant points resulted in a 15â€“20 second delay per frame.
- **Failure State:** The Spring Boot Hub would often trigger an `IOException` (Connection Reset) because the DS took too long to finish "speaking" its payload.

### B. The "Vectorized Path" Solution (Current Approach)

- **Method:** Instead of reading the screen, the system now records the **Touch Screen Interrupts** directly. As the stylus moves, the $(x, y)$ coordinates are pushed into a `std::vector<Point>`.
- **Performance:** A typical drawing frame (like the "Cat with Whiskers") contains only ~250 points ($<2KB$ of data) compared to the theoretical $100KB+$ of a full scan.
- **Result:** Transmission is now perceived as instantaneous.

---

## 3. Hardware Implementation & The "Blank Screen" Hurdle

### A. Solving the Top Screen Initialization Failure

A major technical hurdle was the "Black Screen" issue where the `consoleInit` driver failed to display text on the top screen.

- **The Problem:** By default, the DS initializes the console on the bottom screen, conflicting with the drawing engine.
- **The Fix:** We implemented `lcdMainOnTop()` to physically swap the engine output.
- **Manual Mapping:** - `vramSetBankA(VRAM_A_MAIN_BG)`: Dedicated specifically for the text console on the Top Screen (Main Engine).
  - `vramSetBankC(VRAM_C_SUB_BG)`: Dedicated to the 16-bit Bitmap drawing on the Bottom Screen (Sub Engine).
  - **Explicit Console Call:** `consoleInit(NULL, 0, BgType_Text4bpp, BgSize_T_256x256, 31, 0, true, true)` was configured to force the main engine, ensuring the "Legend" and "Status" are always visible.

### B. High-Fidelity 16-Bit Drawing

To overcome the "blobby" look of standard 8-bit modes, we utilized `BgType_Bmp16`.

- **Thick Brush Logic:** Implemented `drawThickBrush(int x, int y)` which writes a 5x5 matrix of `COLOR_BLACK` ($0x8000$) directly into `canvasMemory`. This ensures the user sees a smooth, bold line that matches what the AI/Python script will eventually render.

---

## 4. Transmission & Memory Integrity

### A. The "Pen-Lift" Sentinel (255, 255)

To prevent "ghost lines" (diagonal streaks connecting separate strokes), we utilized the `keysUp(KEY_TOUCH)` state.

- **Logic:** `if ((kUp & KEY_TOUCH) && isDrawing) { currentFramePath.push_back({255, 255}); }`
- **Why it works:** By injecting an out-of-bounds coordinate (since DS Y-max is 191), the Java Hub knows exactly when to stop drawing the current line segment.

### B. TCP Linger & Wi-Fi Stability

The DS Wi-Fi hardware (`dswifi`) is notorious for closing sockets before the final packet clears the hardware buffer.

- **Fix:** In `network.cpp`, we implemented a **30-frame VBlank Linger** (`for(int i=0; i<30; i++) swiWaitForVBlank();`) after the `send()` call. This allows the ARM7 co-processor enough time to empty the Wi-Fi TX buffer before `close(sock)` is called.

---

## 5. Software Architecture Upgrades

### A. Java Spring Boot Hub (`DsController.java`)

The Hub was refactored to handle the new `text/plain` format:

- **`ConcurrentHashMap` Storage:** Stores frames by UUID.
- **Full Raw Log:** Replaced "Data Preview" with a full console dump to allow the developer to see every coordinate, including the `255,255` break points.

### B. C++ User Interface Legend

The Top Screen now serves as the **Control Legend**:

- **(Y)**: START NEW SESSION (`GET /session/new`)
- **(A)**: SEND FRAME (`POST /session/frame`) - Clears canvas and vector list simultaneously.
- **(X)**: ANIMATE! (`GET /session/done`) - Signals the Python worker.

---

## 6. Technical Summary Table

| Milestone                    | Hardware Solution                      | Result                                      |
| :--------------------------- | :------------------------------------- | :------------------------------------------ |
| **Top Screen Display**       | `lcdMainOnTop()` + Bank A mapping      | **Fixed:** UI and Drawing isolated.         |
| **Drawing Lag**              | Vectorized `std::vector<Point>`        | **Zero Latency** stylus tracking.           |
| **Transmission Reliability** | 30-Frame VBlank Linger                 | **100% Packet Delivery** success.           |
| **SD Compatibility**         | `fat:/config.txt` + 30-frame init wait | **Stable config loading** in TWiLight Menu. |

---

_End of Specification 006_
